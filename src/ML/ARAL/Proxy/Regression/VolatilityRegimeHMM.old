{-# LANGUAGE DeriveAnyClass       #-}
{-# LANGUAGE DeriveGeneric        #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE ScopedTypeVariables  #-}
{-# LANGUAGE TupleSections        #-}
{-# LANGUAGE TypeFamilies         #-}
{-# LANGUAGE TypeSynonymInstances #-}
module ML.ARAL.Proxy.Regression.VolatilityRegime
    ( HMM
    , RegimeDetection (..)
    , addValueAndTrainHMM
    , getStateMeans
    , getStateCov
    , hmm
    , currentRegime
    , currentRegimeWithTransF
    , currentRegimeExp
    , State (..)
    ) where

import           Control.DeepSeq
import           Data.Default
import           Data.List                                       (foldl')
import qualified Data.List.Extra                                 as List
import qualified Data.Map.Strict                                 as M
import           Data.Maybe                                      (fromMaybe)
import           Data.Monoid
import           Data.Serialize
import           Data.Vector.Serialize                           ()
import           Debug.Trace
import           GHC.Generics
import qualified Numeric.LAPACK.Matrix.HermitianPositiveDefinite as HermitianPD

import           Statistics.Sample.WelfordOnlineMeanVariance

import qualified Control.Monad.Exception.Synchronous             as Exceptional
import           Foreign.Storable                                (Storable)
import           Numeric.LAPACK.Matrix                           ((#!))
import qualified Numeric.LAPACK.Matrix                           as Matrix
import qualified Numeric.LAPACK.Matrix.Square                    as Square
import qualified Numeric.Netlib.Class                            as Class

import qualified Math.HiddenMarkovModel                          as HMM
import qualified Math.HiddenMarkovModel.Distribution             as Distr

import qualified Data.Vector                                     as VB
import qualified Data.Vector.Storable                            as VS
import qualified Numeric.LAPACK.Matrix.Array                     as ArrMatrix
import qualified Numeric.LAPACK.Matrix.Hermitian                 as Hermitian
import qualified Numeric.LAPACK.Matrix.Layout                    as Layout
import qualified Numeric.LAPACK.Matrix.Triangular                as Triangular
import           Numeric.LAPACK.Vector                           (Vector, singleton, (.*|))
import qualified Numeric.LAPACK.Vector                           as Vector

import qualified Data.Array.Comfort.Boxed                        as Array
import qualified Data.Array.Comfort.Shape                        as Shape
import qualified Data.Array.Comfort.Storable                     as StorableArray

import           Data.Function.HT                                (nest)
import qualified Data.NonEmpty                                   as NonEmpty
import qualified Data.NonEmpty.Class                             as NonEmptyC
import           Data.Tuple.HT                                   (mapSnd)


squareFromLists :: (Shape.C sh, Eq sh, Storable a) => sh -> [Vector sh a] -> Matrix.Square sh a
squareFromLists sh = Square.fromFull . Matrix.fromRowArray sh . Array.fromList sh

squareToRowLists :: (Shape.C sh, Eq sh, Class.Floating a, Storable a) => Matrix.Square sh a -> [Vector sh a]
squareToRowLists = Matrix.toRows

squareToList :: (Shape.C sh, Eq sh, Class.Floating a, Storable a) => Matrix.Square sh a -> [a]
squareToList = concatMap Vector.toList . squareToRowLists


gaussianToList :: (Shape.C sh) => Distr.T (Distr.Gaussian emiSh) sh a -> [(a, Vector emiSh a, Matrix.Upper emiSh a)]
gaussianToList (Distr.Gaussian params) = Array.toList params


-- diagGaussianFromList :: (Shape.C sh) => [(Double, Double)] -> Distr.T (Distr.Gaussian emiSh) sh Double
-- diagGaussianFromList xs =

--   Distr.gaussian $ Array.fromList stateSet $ map ((, Hermitian.diagonal Layout.RowMajor (Array.fromList sh (repeat 1))) . fst) xs
  -- map (\(m,var) ->
  --           (singleton   0.5 , Hermitian.identity Layout.RowMajor ()) :
  --           (singleton   5.0 , Hermitian.identity Layout.RowMajor ()) :
  --        )

-- toGaussian ::
--    (Shape.C emiSh, Class.Real prob) =>
--    (Vector emiSh prob, Matrix.HermitianPosDef emiSh prob) ->
--    (prob, Vector emiSh prob, Triangular.Upper emiSh prob)
-- toGaussian (center, covariance) =

--    gaussianFromCholesky center $ HermitianPD.decompose covariance


normalizeProb :: (Shape.C sh, Class.Real a) => Vector sh a -> Vector sh a
normalizeProb = snd . normalizeFactor


normalizeFactor :: (Shape.C sh, Class.Real a) => Vector sh a -> (a, Vector sh a)
normalizeFactor xs =
  let c = Vector.sum xs
   in (c, recip c .*| xs)

------------------------------

data State = Low | High
-- data State = Rising | High | Falling | Low
   deriving (Eq, Ord, Enum, Bounded, NFData, Generic, Serialize, Show)

type StateSet = Shape.Enumeration State

stateSet :: StateSet
stateSet = Shape.Enumeration


type HMM = HMM.Gaussian () StateSet Double

data RegimeDetection =
  RegimeDetection
    { regimeTrainedModel  :: Maybe (HMM.Gaussian () StateSet Double)
    , regimeInputCache    :: VS.Vector Double
    , regimeWelfordStates :: M.Map State (WelfordExistingAggregate Double) -- ^ One Welford for every state.
    , regimeWelfordAll    :: WelfordExistingAggregate Double               -- ^ Welford for values.
    , regimeTrainSize     :: Int
    , regimeExpSmth       :: (Double, Double, State, Int)
    }
  deriving (NFData, Generic, Serialize)

instance Show RegimeDetection where
  show (RegimeDetection (Just model) _ wel welAll _ _) = show (HMM.transition model) ++ "\n" ++ show (HMM.distribution model) ++ "\n" ++ show wel ++ "\n" ++ show welAll
  show (RegimeDetection Nothing _ _ _ _ _)             = "Empty HMM model"


instance Default RegimeDetection where
  def = RegimeDetection Nothing VS.empty (M.fromList $ zip [minBound .. maxBound] (repeat WelfordExistingAggregateEmpty)) WelfordExistingAggregateEmpty 1000 (0, 0, Low, 0)


instance Serialize HMM where
  put mdl = put (HMM.toCSV mdl)
  get = do
    (eTxt :: String) <- get
    return $ error $ "TODO:\n" ++ eTxt
      -- case Exceptional.toEither (HMM.fromCSV (Shape.zeroBasedSize) eTxt) of
      --   Right (hmm :: HMM) -> hmm -- (hmm :: HMM)
      --   Left str           -> undefined -- error str


hmm :: HMM
hmm =
   HMM.Cons {
      HMM.initial = normalizeProb $ Vector.one stateSet,
      HMM.transition =
         squareFromLists stateSet $
            -- --          Ris Hig Fall Low
            -- stateVector 0.99 0.0 0.0 0.01 : -- Ris
            -- stateVector 0.01 0.99 0.0 0.0 : -- High
            -- stateVector 0.0 0.01 0.99 0.0 : -- Fall
            -- stateVector 0.0 0.0 0.01 0.99 : -- Low
            --           Low Hig
            stateVector 0.95 0.05 : -- Low
            stateVector 0.05 0.95 : -- High
            [],
      HMM.distribution =
         Distr.gaussian $ Array.fromList stateSet $
            (singleton   0.5 , Hermitian.identity Layout.RowMajor ()) :
            (singleton   5.0 , Hermitian.identity Layout.RowMajor ()) :
            -- (singleton   0 , Hermitian.identity Layout.RowMajor ()) :
            -- (singleton (-1), Hermitian.identity Layout.RowMajor ()) :
            []
   }

-- stateVector :: Double -> Double -> Double -> Double -> Vector StateSet Double
-- stateVector x0 x1 x2 x3 = Vector.fromList stateSet [x0,x1,x2,x3]

stateVector :: Double -> Double -> Vector StateSet Double
stateVector x0 x1 = Vector.fromList stateSet [x0,x1]


{- |
>>> take 20 $ map fst $ NonEmpty.flatten sineWaveLabeled
[Rising,Rising,High,High,High,Falling,Falling,Falling,Low,Low,Low,Rising,Rising,Rising,Rising,High,High,High,Falling,Falling]
-}
sineWaveLabeled :: NonEmpty.T [] (State, Double)
sineWaveLabeled =
   NonEmpty.mapTail (take 200) $
   fmap (\x -> (toEnum $ mod (floor (x*2/pi+0.5)) 4, sin x)) $
   NonEmptyC.iterate (0.5+) 0

sineWave :: NonEmpty.T [] Double
sineWave = fmap snd sineWaveLabeled

{- |
>>> take 20 $ NonEmpty.flatten revealed
[Rising,Rising,High,High,High,Falling,Falling,Falling,Low,Low,Low,Low,Rising,Rising,Rising,High,High,High,Falling,Falling]
-}
revealed :: NonEmpty.T [] State
revealed = HMM.reveal hmmTrainedSupervised $ fmap singleton sineWave

hmmTrainedSupervised :: HMM
hmmTrainedSupervised =
   HMM.finishTraining $ HMM.trainSupervised stateSet $
   fmap (mapSnd singleton) sineWaveLabeled

hmmTrainedUnsupervised :: HMM
hmmTrainedUnsupervised =
   HMM.finishTraining $ HMM.trainUnsupervised hmm $ fmap singleton sineWave

-- hmmIterativelyTrained :: HMM
-- hmmIterativelyTrained =
--    nest 100
--       (\model ->
--          HMM.finishTraining $ HMM.trainUnsupervised model $
--          fmap singleton sineWave)
--       hmm

transformValue :: Double -> Double
transformValue = id

hermitianFromList ::
   (Shape.C sh, Class.Floating a) => sh -> [a] -> Hermitian.Hermitian sh a
hermitianFromList = Hermitian.fromList Layout.RowMajor


updateExp :: WelfordExistingAggregate Double -> (Double, Double, State, Int) -> Double -> (Double, Double, State, Int)
updateExp wel (fastExp, slowExp, curSt, nr) x = (fastExp', slowExp', curSt', nr')
  where
    nr' | curSt == curSt' = nr+1
        | otherwise = 1
    (mean, _, variance) = case wel of
      WelfordExistingAggregate{}    -> finalize wel
      WelfordExistingAggregateEmpty -> (0, 0, 0)
    fastExp' = (1 - alphaFast) * fastExp + alphaFast * abs x
    slowExp' = (1 - alphaSlow) * slowExp + alphaSlow * abs x
    alphaFast = 0.05
    alphaSlow = 0.01
    border = mean + sqrt variance
    curSt' = case curSt of
      Low  | fastExp' > border && slowExp' > 0.612 * border           -> High
      -- Low  | fastExp' > 0.612 * border && slowExp' <= 0.612 * border  -> Low
      -- High | fastExp' > border                                        -> High
      -- High | fastExp' <= border && slowExp' > 0.612 * border          -> High
      High | fastExp' <= 0.612 * border && slowExp' <= 0.612 * border -> Low


       -- High | fastExp' <= border && slowExp' <=                        -> Low
      -- Low  | fastExp' <= 0.612 * border                               -> Low
      st                                                              -> st
      -- Low  | fastExp' > border && slowExp' <= border  -> Low
      -- Low  | fastExp' > border && slowExp' > border   -> High


addValueAndTrainHMM :: RegimeDetection -> [Double] -> RegimeDetection
addValueAndTrainHMM (RegimeDetection Nothing cache welSt welAll sz expSmth) xs
  | VS.length cache < max 1000 (3 * sz) = RegimeDetection Nothing cache' welSt welAll' sz expSmth'
  | nrStates == 1 = error "addValueAndTrainHMM: Need at least 2 possible states"
  | otherwise = addValueAndTrainHMM (RegimeDetection (Just initModel) cache welSt welAll sz expSmth') xs
  where
    expSmth' = updateExp welAll' expSmth (last xs)
    welAll' = foldl' addValue welAll xs
    cache' = cache VS.++ VS.fromList (map transformValue xs)
    (mean, _, variance) = finalize welAll'
    stdev = max 1e-3 (sqrt variance)
    maxVal = mean + stdev
    step = (maxVal - mean) / fromIntegral (nrStates - 1)
    nrStates = length ([minBound .. maxBound] :: [State])
    -- hermitianPD =
    --            HermitianPD.assurePositiveDefiniteness .
    --            hermitianFromList stateSet
    -- cov0 = hermitianPD [0.10, -0.09, 0.10]
    -- cov1 = hermitianPD [0.10,  0.09, 0.10]
    distr =
      Distr.gaussian $
      Array.fromList stateSet $ reverse $ take nrStates $ map (\x -> (singleton x, Hermitian.identity Layout.RowMajor ())) [mean,mean + step ..]
    initModel = HMM.uniform distr
addValueAndTrainHMM (RegimeDetection (Just model) cache welSt welAll sz expSmth) xs
  | VS.length cache < sz = RegimeDetection (Just model) cache' welSt welAll' sz expSmth'
  | isBroken model' =
    trace ("\nOld model: " ++ show model)
    trace ("\nBroken model: " ++ show model')
    trace ("\nNew size: " ++ show (2*sz))
    RegimeDetection (Just model) cache' welSt welAll' (2*sz) expSmth' -- increase number of values
  | otherwise =
    trace ("\n\nNEW MODEL: " ++ show model')
    RegimeDetection (Just model') (VS.singleton $ VS.last cache') welSt' welAll' sz expSmth'
  where
    expSmth' = updateExp welAll' expSmth (last xs)
    welAll' = foldl' addValue welAll xs
    cache' = cache VS.++ VS.fromList (map transformValue xs)
    -- (mean, _, variance) = finalize welAll'
    -- stdev = max 1e-3 (sqrt variance)
    trainExamplesU = VS.head cache' NonEmpty.!: VS.toList (VS.tail cache')
    trainExamplesSLs = map (labelEmission welAll') (VS.toList cache')
    trainExamplesS = fromMaybe (error "empty vector") $ NonEmpty.fetch $ fmap (mapSnd singleton) trainExamplesSLs
    -- label (VS.head cache') NonEmpty.!: map label (VS.toList (VS.tail cache'))
    -- label x = (fst $ head $ filter (\(s,v) -> abs x < v) $ zip states [mean + step, mean + 2*step ..] ++ [(last states, abs x + 1)], x)
    mkValues :: State -> [Double]
    mkValues st = map snd $ filter ((== st ) . fst ) trainExamplesSLs
    welSt' = foldl' (\m st -> M.alter (Just . maybe (addValues WelfordExistingAggregateEmpty (mkValues st) ) (`addValues` mkValues st)) st m) welSt states
    -- maxVal = mean + 0.618 * stdev
    -- step = (maxVal - mean) / fromIntegral (nrStates - 1)
    states = [minBound .. maxBound] :: [State]
    -- nrStates = length states
    -- distrs = HMM.distribution $ HMM.finishTraining $ HMM.trainSupervised stateSet trainExamplesS -- distributions are learned supervised to prevent divergence
    setDistr hmm = hmm { HMM.distribution = mkGaussian (map ((\(m,_,v) -> (m, [v])) . finalize) (M.elems welSt')) }
    model' =
      -- trace ("trainExamplesL: " ++ show trainExamplesS)
      -- mergeModels model $
      fixParams $ setDistr $
      -- -- TODO: use variance and mean from welford!
      nest 10 (\mdl -> HMM.finishTraining $ HMM.trainUnsupervised (setDistr mdl) $ fmap singleton trainExamplesU) model
      -- nest 10 (\mdl -> HMM.finishTraining $ HMM.trainUnsupervised mdl $ fmap singleton trainExamplesU) model

      -- HMM.finishTraining $
      -- HMM.trainSupervised stateSet trainExamplesS

    fixParams mdl =
      mdl { HMM.initial = normalizeProb $ Vector.fromList stateSet [0.5, 0.5] --  $ map (max 0.5 . min 0.5) $ Vector.toList (HMM.initial mdl) -- [0.682, 0.318] -- $ map (max 0.5 . min 0.5) $ Vector.toList (HMM.initial mdl)}
          -- , HMM.transition = squareFromLists stateSet $
          --   stateVector 0.99 0.01 :
          --   stateVector 0.01 0.99 :
          --   []
          }

    isBroken mdl =
      any (\x -> -- trace ("x: " ++ show x ++ " test: " ++ show (x > 0.9999, x < 0.0001, isNaN x))
              x > 0.9999 || x < 0.0001 || isNaN x) (concatMap Vector.toList $ squareToRowLists $ HMM.transition mdl)
      -- &&
      -- all (\(x, vec, mat) -> not . isNaN $ x) (gaussianToList $ HMM.distribution mdl)

-- | Given the welford aggregate of all inputs, the emissions are labeled.
labelEmission :: WelfordExistingAggregate Double -> Double -> (State, Double)
labelEmission welAll x = (fst . head . filter (\(s, v) -> abs x < v) $ stateLimits, x)
  where
    states = [minBound .. maxBound] :: [State]
    nrStates = length states
    step = (maxVal - mean) / fromIntegral (nrStates - 1)
    stateLimits = zip states [mean + step,mean + 2 * step ..] ++ [(last states, abs x + 1)] -- abs x + 1 ensures there will always be a matching value
    maxVal = mean + 0.5 * sqrt variance
    (mean, _, variance) = finalize welAll


mkGaussian :: [(Double, [Double])] -> Distr.T (Distr.Gaussian ()) StateSet Double
mkGaussian xs =
  Distr.gaussian $ Array.fromList stateSet $ zipWith (\m v -> (singleton m, hermitian v)) means var

  where means = map fst xs -- Vector.fromList stateSet (map fst xs)
        var = map snd xs -- map (Triangular.fromList Layout.RowMajor stateSet) (map snd xs)
        hermitian = HermitianPD.assurePositiveDefiniteness . Hermitian.fromList Layout.RowMajor ()
        -- hermitianPD = HermitianPD.assurePositiveDefiniteness . hermitianFromList stateSet


-- mergeModels :: (Distr.Estimate typ, Shape.C sh, Eq sh, Class.Real prob) => HMM.T typ sh prob -> HMM.T typ sh prob -> HMM.T typ sh prob
-- mergeModels hmm0 hmm1 =
--    HMM.Cons {
--         HMM.initial      = normalizeProb $ Vector.add (HMM.initial hmm0) (HMM.initial hmm1)
--       , HMM.transition   = normalizeProbColumns $ Matrix.add (HMM.transition hmm0) (HMM.transition hmm1)
--       , HMM.distribution = normalizeGaussian $ HMM.distribution hmm0 <> HMM.distribution hmm1
--    }

-- normalizeGaussian :: (Shape.C sh, Eq sh, Class.Real prob) => HMM.T typ sh prob -> HMM.T typ sh prob
-- normalizeGaussian (Distr.Gaussian m) =
--       let params (weight, centerSum, covarianceSum) =
--              let c = recip (weight #! ((),()))
--                  center = Vector.scale c $ Matrix.flattenRow centerSum
--              in  (center,
--                   HermitianPD.assurePositiveDefiniteness $
--                   Matrix.sub
--                      (Matrix.scaleRealReal c covarianceSum)
--                      (Hermitian.relaxIndefinite $
--                       Hermitian.outer Layout.RowMajor center))
--       in Distr.Gaussian $
--          fmap (Distr.gaussianParameters . params .
--                Hermitian.split . ArrMatrix.fromVector) $
--          Matrix.toRowArray $ Matrix.fromRowMajor m


normalizeProbColumns ::
   (Shape.C sh, Eq sh, Class.Real a) => Matrix.Square sh a -> Matrix.Square sh a
normalizeProbColumns m =
   Matrix.scaleColumns (StorableArray.map recip (Matrix.columnSums m)) m


-- toTraining :: (Distr.Estimate typ, Shape.C sh, Eq sh, Class.Real prob) => HMM.T typ sh prob -> HMM.Trained typ sh prob
-- toTraining hmm =
--    HMM.Trained {
--       HMM.initial      = HMM.initial hmm,
--       HMM.transition   = HMM.transition hmm,
--       HMM.distribution = HMM.distribution hmm
--    }

-- gaussian :: (Shape.C emiSh, Shape.C stateSh, Class.Real prob) => Array stateSh (Vector emiSh prob, Matrix.HermitianPosDef emiSh prob) -> T (Gaussian emiSh) stateSh prob
-- gaussian = Gaussian . fmap gaussianParameters

-- gaussianParameters :: (Shape.C emiSh, Class.Real prob) => (Vector emiSh prob, Matrix.HermitianPosDef emiSh prob) -> (prob, Vector emiSh prob, Triangular.Upper emiSh prob)
-- gaussianParameters (center, covariance) = gaussianFromCholesky center $ HermitianPD.decompose covariance

-- gaussianFromCholesky :: (Shape.C emiSh, Class.Real prob) => Vector emiSh prob -> Triangular.Upper emiSh prob -> (prob, Vector emiSh prob, Triangular.Upper emiSh prob)
-- gaussianFromCholesky center covarianceChol =
--   let covarianceSqrtDet = Vector.product $ Triangular.takeDiagonal covarianceChol
--    in (recip (sqrt2pi ^ vectorDim center * covarianceSqrtDet), center, covarianceChol)

getStateMeans :: RegimeDetection -> [Double]
getStateMeans (RegimeDetection (Just model) _ _ _ _ _) = concatMap (\(weigth,center,cov) -> Vector.toList center) $ gaussianToList $ HMM.distribution model
getStateMeans _                                        = replicate (length [minBound..(maxBound :: State)]) 0

getStateCov :: RegimeDetection -> [Double]
getStateCov (RegimeDetection (Just model) _ _ _ _ _) = concatMap (\(weigth,center,cov) -> Vector.toList $ Triangular.takeDiagonal cov) $ gaussianToList $ HMM.distribution model
getStateCov _                                        = replicate (length [minBound..(maxBound :: State)]) 0


mapTransition :: (Double -> Double) -> HMM.Gaussian () StateSet Double -> HMM.Gaussian () StateSet Double
mapTransition f model = model {HMM.transition = normalizeProbColumns $ Square.fromList stateSet $ map f $ squareToList $ HMM.transition model}


-- dropDistrWeigths :: RegimeDetection -> RegimeDetection
-- dropDistrWeigths (RegimeDetection (Just model) _ _ _ _) = Distr.gaussian $ Array.map (\(_, mean, cov) -> (mean, Distr.extendedHermitian (Matrix.toRows cov))) $ (\(Distr.Gaussian params) -> params) $ HMM.distribution model
-- dropDistrWeigths reg                                    = reg


currentRegime :: RegimeDetection -> VS.Vector Double -> State
currentRegime = currentRegimeWithTransF id


-- | Given a list of emissions with the latest data point enabled, returns the most probable next state.
currentRegimeWithTransF :: (Double -> Double) -> RegimeDetection -> VS.Vector Double -> State
currentRegimeWithTransF f (RegimeDetection (Just model) _ _ welAll _ _) emissions
  | VS.length emissions < 3 = toEnum 0
--   | otherwise = last $ NonEmpty.flatten $ HMM.reveal (mapTransition f model) $ fmap singleton $ transformValue (VS.head emissions) NonEmpty.!: VS.toList (VS.map transformValue $ VS.tail emissions)
  | otherwise = fst . List.maximumOn snd $ fmap (\st -> (st, ) . computeProbability st $ labeledEmissionsWoLast) [minBound .. maxBound]
  where
    e = VS.last emissions
    labeledEmissionsWoLast :: VB.Vector (State, Double)
    labeledEmissionsWoLast = fmap (labelEmission welAll) . VS.convert $ VS.init emissions
    computeProbability :: State -> VB.Vector (State, Double) -> Double
    computeProbability st vec = VB.last . HMM.probabilitySequence (mapTransition f model) . fmap (mapSnd singleton) $ vec `VB.snoc` (st, e)
currentRegimeWithTransF _ _ _ = toEnum 0

currentRegimeExp :: RegimeDetection -> State
currentRegimeExp (RegimeDetection _ _ _ welAll _ (_, _, st, _)) = st
